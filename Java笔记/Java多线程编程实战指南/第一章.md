# 一、进程和线程
## 1. 进程
  > 进程代表运行中的程序，一个进程可以包含多个线程。

## 2. 线程
  > 线程是进程中可独立执行的子任务，同一个进程中的线程共享该进程所申请到的资源，如内存空间和文件句柄等。从JVM的角度来看，线程是进程中的一个组件，它可以看做执行Java代码的最小单位。

**守护线程**

> 守护线程不会影响JVM的正常停止，即应用程序中有守护线程在运行也不影响JVM的正常停止。

**用户线程**

> 用户线程会组织JVM的正常停止，即JVM正常停止前应用程序的所有用户线程必须先停止完毕，否则JVM无法停止。

### 2.1. 线程的创建与运行

> 创建一个线程就是创建一个Thread类的实例，需要进行内存分配，JVM会为Thread实例分配两个调用栈(Call Stack)做需的空间，一个是用于跟踪Java代码间的调用关系，另一个用于跟踪Java代码对本地代码的调用关系。

**两种方式**
* 实现Runnable接口
* 继承Thread类

### 2.2. 线程的状态
  可以通过Thread.getState方法来获取线程的状态，Thread.State是个枚举值。
* NEW
  > 一个刚创建而未启动的线程处于该状态，由于一个线程实例只能被启动一次，因此一个线程只可能有一次处于该状态。

* RUNNABLE
  > 复合状态，包括READY和RUNNING。READY表示处于该状态的线程可以被JVM的线程调度器(Scheduler)进行调度而使之处于RUNNING状态。RUNNING表示该状态的线程正在运行，即相应线程对象的run方法中的代码所对应的指令正在由CPU执行。

* BLOCKED
  > 一个线程发起一个阻塞式 I/O 操作后，或者试图去获得一个由其他线程持有的锁时，相应的线程会处于该状态。处于该状态的线程并不会占用CPU资源，当相应的 I/O 操作完成后，或者响应的锁被其他线程释放后，该线程的状态又可以转换为RUNNABLE。

* WAITING
  > 一个线程执行了某些方法调用之后就会处于这种无限等待其他线程执行操作的状态，这些方法包括: Object.wait(), Thread.join(), LockSupport.park()。能够使相应线程从 WAITING 转到 RUNNABLE 的相应方法包括：Object.notify(), Object.notifyAll()和LockSupport.unpark(thread)。

* TIMED_WAITING
  > 该状态喝 WAITING 状态类似，差别在于处于该状态的线程并非无限等待其他线程执行特定操作，而是处于带有时间限制的等待状态。当其他线程没有在指定时间内执行该线程所期望的特定操作时，该线程的状态自动转为 RUNNABLE。

* TERMINATED
  > 已经执行结束的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程也只可能有一次处于该状态。Thread实例的run方法正常返回或者由于抛出异常而提前终止都会导致相应线程处于该状态。

**上写文切换**

多线程环境中，状态之间的转换时，相应的上下文信息需要被保存，包括CPU的寄存器喝程序计数器在某一时间点的内容。
