### Java 多线程

  ---
#### 1. 目的

更好的利用CPU的资源

#### 2. 基本概念

* **多线程:** 一个程序或者一个进程运行时产生的不止一个线程

* **并行与并发:**
  * **并行(parallel):** 多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。

  * **并发(concurrent):** 通过cpu调度算法，让用户看上去同时执行，实际上cpu操作层面不是真正的同时。

* **线程安全: **

* **同步: ** Java中的同步指的是通过认为的控制和调度，保证共享资源的多线程访问成为线程安全，来确保结果的准确。`线程安全的优先级高于性能`。

#### 3. 线程的状态

* 就绪状态：线程创建之后，调用start()方法，线程进入就绪状态，等待被cpu调度。

* 运行状态：就绪状态的线程获得cpu资源后，执行响应的程序。

* 阻塞状态：因为某种原因释放cpu资源，暂时停止运行。

  * 等待阻塞：运行的线程执行wait()方法，该线程释放所有的资源，线程进入`等待池`中，进入这个状态后，该线程是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒。

  * 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程占用，则JVM会把该线程放入`锁池`中

  * 其他阻塞：运行线程调用sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或中断、I/O处理完毕时，线程重新回到就绪状态。

* 死亡状态：线程执行完毕或者异常退出了run()方法。

#### 4.每个对象都有的方法
* **synchronized、wait、notify**

    Java中每个对象都有个监视器，来监测并发代码的重入，非多线程下不发挥作用，在synchronized范围内会发挥作用。wait和notify必须在synchronized块中，否则会抛出IllegalMonitorStateException异常。

#### 5. 多线程的内存模型

多线程的内存模型分为：主存和线程栈，在处理数据时，线程会把值从主存中load到本地栈，完成操作之后再save到回去。

* **volatile关键字：**

    使用volatile修饰的变量，每次针对该变量的操作都会发一次load和save。多线程是会缓存值的，而volatile就不会缓存值，修改修改变量后立刻写回主存。在线程安全额情况下使用volatile会影响性能。

    使用volatile修饰的long和double变量时，可以保证原子性。如果不用volatile, 一个线程在修改long或者double变量的值，另一个线程可能只能看到该值的一半(32位)。

#### 6. 基本的线程类

* **Thread类 **

  **Thread.yield():** 转让cpu控制权，运行状态-->就绪状态

  **Thread.sleep():** 线程暂停一段时间，运行状态-->阻塞状态

  **join():** A线程中执行B线程join(), B线程执行完毕后才继续执行A线程，运行状态-->阻塞状态

  **interrupte():**

* **Runnable接口: **

  与Thread类似

* **Callable接口: **

  future模式：并发模式的一种，可以有两种形式，即无阻塞和阻塞，分别是isDone和get

#### 7. 多线程的控制类

* **ThreadLocal类:**

    当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，每个线程都可以独立的改变自己的副本，而不会影响其他线程的副本，是线程隔离的，参考ThreadLocalMap类。

    注意：工作线程比任何应用变量的生命周期都长，任何线程的局部变量在工作完成后没有释放，就会存在类存泄露的风险。

    通过ThreadLocal创建的变量副本存储在每个线程的threadLocals中。

* **Lock类:**

---
